package frc.robot.subsystems;import com.ctre.phoenix.motorcontrol.ControlMode;import com.ctre.phoenix.motorcontrol.NeutralMode;import com.ctre.phoenix.motorcontrol.can.WPI_TalonFX;import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;import edu.wpi.first.networktables.GenericEntry;import edu.wpi.first.util.sendable.SendableBuilder;import edu.wpi.first.wpilibj.shuffleboard.Shuffleboard;import edu.wpi.first.wpilibj.shuffleboard.ShuffleboardTab;import edu.wpi.first.wpilibj.DigitalInput;import edu.wpi.first.wpilibj.motorcontrol.MotorControllerGroup;import edu.wpi.first.wpilibj2.command.CommandBase;import edu.wpi.first.wpilibj2.command.SubsystemBase;import frc.robot.Constants;import frc.robot.Constants.CAN;import frc.robot.RobotContainer;public class ExtensionArm extends SubsystemBase {private final WPI_TalonFX m_leftMotor;private final WPI_TalonFX m_rightMotor;private final MotorControllerGroup m_extensionMotors;private final DigitalInput m_limitSwitch;private boolean isZeroed = false;/**Extension arm testing constants*/public static double maxExtensionTicks = 100; public static double kExtensionDeadband = 0.05; public static double percentage = 15;public static double slowExtensionEndsDistance = (percentage / 100) * maxExtensionTicks; public static double extensionTicksToArmDistance = 0; public static double extensionFactorScalar = slowExtensionEndsDistance; public static double dumbSpeed = .15;public ExtensionArm() {m_leftMotor = new WPI_TalonFX(Constants.CAN.leftMotor);m_rightMotor = new WPI_TalonFX(Constants.CAN.rightMotor);m_limitSwitch = new DigitalInput(CAN.limitSwitch);m_rightMotor.configFactoryDefault();m_leftMotor.configFactoryDefault();m_leftMotor.configVoltageCompSaturation(Constants.Extension.maxVoltage);m_rightMotor.configVoltageCompSaturation(Constants.Extension.maxVoltage);m_leftMotor.enableVoltageCompensation(true);m_rightMotor.enableVoltageCompensation(true);m_rightMotor.setInverted(false);m_leftMotor.setInverted(true);m_extensionMotors = new MotorControllerGroup(m_leftMotor, m_rightMotor);m_leftMotor.setNeutralMode(NeutralMode.Brake);m_rightMotor.setNeutralMode(NeutralMode.Brake);}/**returns if the limit switch has been hit*/public boolean LimitSwitch(){return m_limitSwitch.get();}public double getPosition(){return m_leftMotor.getSelectedSensorPosition() * extensionTicksToArmDistance;}public double getSpeed(){return m_leftMotor.getSelectedSensorVelocity() * extensionTicksToArmDistance;}public void setSpeed(double speed){m_rightMotor.set(ControlMode.PercentOutput, speed);m_leftMotor.set(ControlMode.PercentOutput, speed);}public void stop(){m_rightMotor.set(ControlMode.PercentOutput,0);m_leftMotor.set(ControlMode.PercentOutput,0);}/**zeroes encoders*/public void resetEncoders(){m_leftMotor.setSelectedSensorPosition(0);m_rightMotor.setSelectedSensorPosition(0);}public void setZeroed(){isZeroed = true;}public boolean isZeroed(){return isZeroed;}/**returns if the arm has retracted or extended into the danger(slow) zones*/public boolean inSlowZone() {if((getPosition()<=slowExtensionEndsDistance)&&(getPosition()>=maxExtensionTicks-slowExtensionEndsDistance)){return true;}else {return false;}}public double slowZoneFactor() {double factor = 1;double maxDistance = maxExtensionTicks;double distance = getPosition();double slowZoneDistance = slowExtensionEndsDistance;double joystickInput = RobotContainer.m_WeaponsGamepad.getRawAxis(1);if (distance <= slowZoneDistance) {if (joystickInput <= 0){ factor = (distance / extensionFactorScalar); }} else if (distance >= (maxDistance - slowZoneDistance)) {if (joystickInput >= 0) {factor = ((maxDistance - distance) / extensionFactorScalar); }} return factor;}public double rawMotorSpeed(double y) {if (kExtensionDeadband >= Math.abs(y)) { return 0;}if (!allowedToMovePastEnds(y)) { return 0;}return y;}public boolean allowedToMovePastEnds(double y) {if (LimitSwitch() && (y <= 0)) { return false;}else if ((getPosition() >= maxExtensionTicks) && (y >= 0)) { return false;}return true;}public void dumbSetSpeed(int x) {setSpeed(dumbSpeed * x);}@Override public void periodic() {}/**Shuffleboard getters and setters for constants*//**these will be used in Extension Arm Commands until constant testing is over*/public double getMaxExtensionTicks(){return maxExtensionTicks;}public void setMaxExtensionTicks(double x){maxExtensionTicks = x;}public double getkExtensionDeadband(){return kExtensionDeadband;}public void setkExtensionDeadband(double x){kExtensionDeadband = x;}public double getSlowExtensionEndsDistance(){return slowExtensionEndsDistance;}public void setSlowExtensionEndsDistance(double x){slowExtensionEndsDistance = x;}public double getExtensionTicksToArmDistance(){return extensionTicksToArmDistance;}public void setExtensionTicksToArmDistance(double x){extensionTicksToArmDistance = x;}public double getExtensionFactorScalar(){return extensionFactorScalar;}public void setExtensionFactorScalar(double x){extensionFactorScalar = x;}public void setDumbSpeed(double x){dumbSpeed = x;}public double getDumbSpeed(){return dumbSpeed;}public double getPercentage() {return percentage;}@Override /**Shuffleboard output*/public void initSendable(SendableBuilder builder){builder.addDoubleProperty("Position", this::getPosition, null);builder.addDoubleProperty("Motor Speed", this::getSpeed, this::setSpeed);builder.addBooleanProperty("Hit Limit Switch", this::LimitSwitch, null);builder.addDoubleProperty("CMax Extension Ticks", this::getMaxExtensionTicks, this::setMaxExtensionTicks);builder.addDoubleProperty("CExtension Deadband", this::getkExtensionDeadband, this::setkExtensionDeadband);builder.addDoubleProperty("CSlow Zone Extension Percentage", this::getPercentage, this::setSlowExtensionEndsDistance);builder.addDoubleProperty("CExtension Ticks to Arm Distance Conversion Factor", this::getExtensionTicksToArmDistance, this::setExtensionTicksToArmDistance); builder.addDoubleProperty("CExtension Factor Scalar", this::getExtensionFactorScalar, this::setExtensionFactorScalar);builder.addDoubleProperty("CDumb", this::getDumbSpeed, this::setDumbSpeed);}@Override public void simulationPeriodic() {}}